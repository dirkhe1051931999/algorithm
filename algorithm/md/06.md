## 动态规划是什么

- 把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解
- 常见：1. 有多少种方式 2. 最大最小值 3. 求存在性（博弈性），可以不可以，存在

## 使用动态规划的步骤

1.  步骤 1：确定状态
2.  步骤 2：转义方程
3.  步骤 3：初始条件和边界情况
4.  步骤 4：计算顺序

## 动态规划与贪心算法的区别

1. 贪心算法对每个子问题的解决方案都做出选择，不能回退
2. 动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，可以回退

## 动态规划使用

1. 斐波那契数列

- 递归的时间复杂度：O(2^n)
- 动态规划的时间复杂度：O(n)

```js
function dynFib(n) {
  var arr = new Array(n);
  arr.fill(0);
  if (n === 1 || n === 2) {
    return 1;
  } else {
    arr[1] = 1;
    arr[2] = 2;
    for (var i = 3; i < n; i++) {
      arr[i] = arr[i - 1] + arr[i - 2];
    }
    return arr[n - 1];
  }
}
console.log(dynFib(10));
function recursiveFib(n) {
  if (n == 1 || n == 2) {
    return 1;
  } else {
    return recursiveFib(n - 1) + recursiveFib(n - 2);
  }
}
```

2. 找硬币问题(leetcode 322)

- 有三种硬币，分别面值 2 元，5 元，7 元。每种硬币足够多，买一本书 27 元，
- `问：如和使用最少的硬币付清，不需要对方找钱`
- 求最大最少题，使用动态规划
- **步骤 1：确定状态， 动态规划需要开一个数组，数组的每个元素 f[i]或 f[i][j]代表什么，最后一步与子问题，最后一步（最后一步的策略）：最后一步是 Ak；子问题：最少硬币拼出更新的面值是- 27-Ak**
- **步骤 2：转义方程，f[X] = min{f[X-2]+1,f(X-5)+1,f[X-7]+1}**
- **步骤 3：初始条件和边界情况：初试条件：f[0] = 0，不能拼出来 f[Y] = 正无穷**
- **步骤 4：计算顺序，f[1],f[2],...,f[27]**

```js
// f[0] = 0
// f[1] = min{f[1-2]+1,f(1-5)+1,f[1-7]+1} = 无穷
// f[2] = min{f[2-2]+1,f(2-5)+1,f[2-7]+1} = 1
// f[3] = min{f[3-2]+1,f(3-5)+1,f[3-7]+1} = 无穷
// f[4] = min{f[4-2]+1,f(4-5)+1,f[4-7]+1} = 2
// f[5] = min{f[5-2]+1,f(5-5)+1,f[5-7]+1} = 1
// f[6] = min{f[6-2]+1,f(6-5)+1,f[6-7]+1} = 3
// f[7] = min{f[7-2]+1,f(7-5)+1,f[7-7]+1} = 1
// ...
// f[27] = min{f[27-2]+1,f(27-5)+1,f[27-7]+1} = 5
// 时间复杂度：钱数*硬币快速 ，27*3

function coinChnage(coins, amount) {
  // 开一个数组
  var f = new Array(amount + 1);
  var len = coins.length;
  // 初始条件
  f[0] = 0;
  for (var i = 1; i <= amount; i++) {
    f[i] = Infinity;
    for (var j = 0; j < len; j++) {
      // 异常情况与边界条件
      if (i >= coins[j] && f[i - coins[j]] + 1 !== Infinity) {
        // 计算顺序
        f[i] = Math.min(f[i - coins[j]] + 1, f[i]);
      }
    }
  }
  if (f[amount] === Infinity) {
    return -1;
  }
  return f[amount];
}
console.log(coinChnage([1, 2, 5], 11));
// 3
```

3. 不同路径（leetcode 62）

- 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）
- 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）
- 问：`总共有多少条不同的路径`
