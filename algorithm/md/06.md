## 动态规划是什么

- 把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解

## 使用动态规划的步骤

1. 找出最优解的性质，刻画其结构特征和最优子结构特征
2. 递归的定义最优值，刻画原问题解与子问题解的关系
3. 自底而上的的方式计算出各个子问题、原问题的最优值，需要避免子问题的重复计算
4. 根据计算最优值时得到的信息，构造最优解

## 动态规划与贪心算法的区别

1. 贪心算法对每个子问题的解决方案都做出选择，不能回退
2. 动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，可以回退

## 动态规划使用

1. 斐波那契数列

- 递归的时间复杂度：O(2^n)
- 动态规划的时间复杂度：O(n)

```js
function dynFib(n) {
  var arr = new Array(n);
  arr.fill(0);
  if (n === 1 || n === 2) {
    return 1;
  } else {
    arr[1] = 1;
    arr[2] = 2;
    for (var i = 3; i < n; i++) {
      arr[i] = arr[i - 1] + arr[i - 2];
    }
    return arr[n - 1];
  }
}
console.log(dynFib(10));
function recursiveFib(n) {
  if (n == 1 || n == 2) {
    return 1;
  } else {
    return recursiveFib(n - 1) + recursiveFib(n - 2);
  }
}
```

2. 找硬币问题

```js
// 1. 有多少种方式
// 2. 最大最小值
// 3. 求存在性（博弈性），可以不可以，存在
// 步骤1：确定状态， 动态规划需要开一个数组，数组的每个元素f[i]或f[i][j]代表什么，最后一步与子问题，最后一步（最后一步的策略）：最后一步是Ak；子问题：最少硬币拼出更新的面值是27-Ak
// 步骤2：转义方程，f[X] = min{f[X-2]+1,f(X-5)+1,f[X-7]+1}
// 步骤3：初始条件和边界情况：初试条件：f[0] = 0，不能拼出来f[Y] = 正无穷
// 步骤4：计算顺序，f[1],f[2],...,f[27]

// 问题1：有三种硬币，分别面值2元，5元，7元。每种硬币足够多，买一本书27元，如和使用最少的硬币付清，不需要对方找钱
// 求最大最少题，使用动态规划
// f[0] = 0
// f[1] = min{f[1-2]+1,f(1-5)+1,f[1-7]+1} = 无穷
// f[2] = min{f[2-2]+1,f(2-5)+1,f[2-7]+1} = 1
// f[3] = min{f[3-2]+1,f(3-5)+1,f[3-7]+1} = 无穷
// f[4] = min{f[4-2]+1,f(4-5)+1,f[4-7]+1} = 2
// f[5] = min{f[5-2]+1,f(5-5)+1,f[5-7]+1} = 1
// f[6] = min{f[6-2]+1,f(6-5)+1,f[6-7]+1} = 3
// f[7] = min{f[7-2]+1,f(7-5)+1,f[7-7]+1} = 1
// ...
// f[27] = min{f[27-2]+1,f(27-5)+1,f[27-7]+1} = 5
// 时间复杂度：钱数*硬币快速 ，27*3

function coinChange(arr, money) {
  var temp = new Array(money + 1);
  var len = arr.length;
  temp[0] = 0;
  for (var i = 1; i <= money; i++) {
    temp[i] = Infinity;
    for (var j = 0; j < len; j++) {
      if (i >= arr[j] && temp[i - arr[j]] != Infinity) {
        temp[i] = Math.min(temp[i - arr[j]] + 1, temp[i]);
      }
    }
  }
  if (temp[money] === Infinity) {
    temp[money] = -1;
  }
  return temp[money];
}
console.log(coinChange([2, 5, 7], 27));
// 5
```
