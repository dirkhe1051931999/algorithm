# 背包型动态规划

1. 背包有最大承重、往背包放的物品有重量和价值
2. 可问：不撑爆背包的前提下，1、装下最多重量物品；2、装下最大总价值物品；3、有多少种方式正好带走满满一书包物品，等等
3. 逐个放入物品，看是否还能放入，关键点：`还有几个物品`，`还剩多少承重`
4. 背包问题中，开的是否能承重数组大小和总承重有关

## 背包型动态规划的使用

1. **0-1 背包**

> 有一个背包，他的容量为 C(Capacity)。现在有 n 中不同的物品，编号为 0…n-1，其中每一件物品的重量为 w(i)，价值为 v(i)。问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大

- 给定 N 个物品，重量分别是正整数 A0,...,A(N-1)
- 一个背包最大承重是正整数 M
- 问：`做多能带走多重物品`
- 如:[2,3,5,7] 最大承重 11，最大带走 2，3，5，一共是 10

- 确定状态

  1. 需要知道 N 个物品是否能拼出重量 W（0~M，最后一步：最后一个物品（重量 A(N-1)）是否进入背包。情况 1：如果前 N-1 个物品能拼出 W，当然前 N 个物品也能拼出 W。情况 2：如果前 N-1 个物品能拼出 W-A(N-1)，再加上最后一个物品就能拼出 W
  2. 例如，4 个物品，重量为 2，3，5，7
  3. 前 3 个物品可以拼出重量 8(3+5)，自然前 4 个物品也可以拼出 8
  4. 前 3 个物品可以拼出重量 2，加上最后一个物品，就可以拼出重量 9

  - `错误的状态`

  1. f[i]表示前 i 个物品拼出的最大重量，比如[3,9,5,2]，最大重量 10
  2. 前 j 个物品拼出的最大重量是 9（j<i），加上最后一个 2，是 11，撑爆背包，如果直接用 9，就不是最优策略
  3. 最优策略是选择前前 j 个物品拼出的重量 3+5=8（j<i），加上最后一个 2，结果是 10，但是 8 不是前 j 个总重量最大的，不满足前 i 个物品拼的最大重量，却算出了最优的结果
  4. 错误原因：`背包问题的重点：不超过一个数的前提下，前j个拼起来最大加最后一个数，不一定是不超过Target的最大重量`

  - `正确的状态`

  1. 设 f[i][w] = 能否用前 i 个物品拼出重量 w(true/false)，其中(0<=w<=M)

- 转义方程
  1. f[i][w] = f[i-1][w] OR f[i-1]w-A[i-1]] f[i-1][w]:能否用前 i-1 个物品拼出重量 w；f[i-1][w-a(i-1)]能否用 i-1 个物品拼出重量 w-A(i-1)，再加上第 i 个物品
- 初始条件与边缘情况
  1. f[0][0] = true
  2. f[0][1...m] = false
  3. 边界情况:数组下标非负数，f[i-1][w-a(i-1)]中的 w>=A(i-1)
- 计算顺序
  1. f[0][1]...f[0][m]
  2. f[1][0]...f[1][m]
  3. ...
  4. f[N][0]...f[N][m]

```js
function twoDimensionArr(m, n, val = undefined) {
  var arr = [];
  for (var i = 0; i <= m; i++) {
    var col = [];
    for (var j = 0; j <= n; j++) {
      col[j] = val;
    }
    arr[i] = col;
  }
  return arr;
}
function backPack(n, arr) {
  var m = arr.length;
  if (m === 0) {
    return 0;
  }
  var f = twoDimensionArr(m + 1, n + 1);
  // 初始化：前0个物品拼出重量0
  f[0][0] = true;
  for (var i = 1; i <= n; i++) {
    // 前0个物品拼出重量1...n
    f[0][i] = false;
  }
  for (var i = 1; i <= m; i++) {
    for (var j = 0; j <= n; j++) {
      // 前i-1个物品拼出重量j
      f[i][j] = f[i - 1][j];
      // 边缘情况，j要大于等于arr[i-1]，如果j=11,最后一个是10000，那么最后一个不算，就在前i-1个物品拼重量j
      if (j >= arr[i - 1]) {
        // 前i-1个物品拼出重量j-arr[i-1]，再加上第i个物品
        f[i][j] |= f[i - 1][j - arr[i - 1]];
      }
    }
  }
  var res = 0;
  // 先把0-n的重量都枚举出来，为true的就是拼的最大重量
  for (var i = n; i >= 0; i--) {
    // 其中第0...n个中，从右往左，第i个位true的就是最大重量
    if (f[m][i]) {
      res = i;
      break;
    }
  }
  return res;
}
var test = [2, 3, 5, 7];
console.log(backPack(11, test));
// 10
```
