# 区间型动态规划

- 给定一个序列/字符串，进行一些操作
- 最后一步将序列/字符串去头/去尾
- 剩下的会是一个区间[i,j]
- 状态为 f[i][j] 表示面对子序列[i,..,j]的最优性质

## 区间型动态规划的使用

1. **最长回文子序列(leetcode 516)**

- 给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为 1000
- 1. 是回文，但不一定连续
- 如："bbbab"的最长回文子序列是 bbbb
- 确定状态
  1. 子问题(长度更短的区间)：要求 S[i,...,j]的最长回文子串分为两种情况，1. S[i]==S[j]头尾相等，就转成 S[i+1,j-1]的回文子串，再加 2，2. S[i]!=S[j]，那么就不要头 S[i+1,j]，或者不要尾 S[i,j-1]求最长回文子串
  2. 状态 f[i][j]为区间[i,j]最长回文子序列
- 转义方程
  1. f[i][j] = max{f[i+1][j],f[i][j-1],f[i+1][j-1] + 2 | S[i]==S[j]}
- 初始条件与边缘情况
  1. f[0][0]=f[1][1]= f[N-1][n-1] = 1 (1 个字母也是一个长度为 1 的回文串)
  2. S[i]==S[i+1] f[i][j+1] = 2 (两个相等，比如 aa)
  3. s[i]!=S[i+1] = 1 (随便去个字符，要么取头或者取尾)
- 计算顺序
  1. 不能按照 i 的顺序去算，区间型动态规划，需要按照长度 j-i 从小到大的顺序去算
  2. 长度 1：f[0][0],f[1][1],f[2][2]...f[N-1][n-1]
  3. 长度 2：f[0][1],f[N-2][n-1]
  4. 长度 N：f[0][n-1]
  5. 结果就是 f[0][n-1]

```js
function twoDimensionArr(m, n, val = undefined) {
  var arr = [];
  for (var i = 0; i < m; i++) {
    var col = [];
    for (var j = 0; j < n; j++) {
      col[j] = val;
    }
    arr[i] = col;
  }
  return arr;
}
function longestPalindromeSubseq(s) {
  var arr = s.split("");
  var n = arr.length;
  if (n === 0) {
    return 0;
  }
  if (n === 1) {
    return 1;
  }
  var f = twoDimensionArr(n, n);
  var len;
  // 长度为1
  for (var i = 0; i < n; i++) {
    f[i][i] = 1;
  }
  // 长度为2
  for (var i = 0; i < n - 1; i++) {
    f[i][i + 1] = arr[i] === arr[i + 1] ? 2 : 1;
  }
  // 长度为N
  for (len = 3; len <= n; len++) {
    for (var i = 0; i <= n - len; i++) {
      var j = i + len - 1;
      f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
      if (arr[i] === arr[j]) {
        f[i][j] = Math.max(f[i][j], f[i + 1][j - 1] + 2);
      }
    }
  }
  return f[0][n - 1];
}
var test = "cbbd";
console.log(longestPalindromeSubseq(test));
// 2
```

```js
// 最长回文序列打印结果
function longestPalindromeSubseq_2(s) {
  var arr = s.split("");
  var n = arr.length;
  if (n === 0) {
    return 0;
  }
  var f = twoDimensionArr(n, n);
  var pi = twoDimensionArr(n, n);
  var len;
  // 长度1
  for (var i = 0; i < n; i++) {
    f[i][i] = 1;
  }
  // 长度2
  for (var i = 0; i < n - 1; i++) {
    f[i][i + 1] = arr[i] === arr[i + 1] ? 2 : 1;
  }
  // 长度N
  for (len = 3; len <= n; len++) {
    // 开始位置
    for (var i = 0; i <= n - len; i++) {
      // 结束位置
      var j = i + len - 1;
      // 去头或者去尾
      f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
      if (f[i][j] === f[i + 1][j]) {
        pi[i][j] = 0;
      }
      if (f[i][j] === f[i][j - 1]) {
        pi[i][j] = 1;
      }
      if (arr[i] === arr[j]) {
        // 去头和尾
        f[i][j] = Math.max(f[i][j], f[i + 1][j - 1] + 2);
        if (f[i][j] === f[i + 1][j - 1] + 2) {
          pi[i][j] = 2;
        }
      }
    }
  }
  // 打印solution
  var resultLen = f[0][n - 1];
  var result = new Array(resultLen);
  // solution开始指针和结束指针
  var p = 0,
    q = resultLen - 1;
  // 字符串arr的开始指针与结束指针，从两头往中间填，从外往里
  var i = 0,
    j = n - 1;
  // 从尾巴开始缩，从两头往中间填，从外往里
  while (i <= j) {
    // 长度为1
    if (i === j) {
      result[p] = arr[i];
      break;
    }
    // 长度为2
    // 此时s[i]是等于s[j]
    if (i + 1 == j) {
      result[p] = arr[i];
      result[q] = arr[j];
      break;
    }
    // 长度为N
    // 去头
    if (pi[i][j] === 0) {
      i++;
    } else if (pi[i][j] === 1) {
      // 去尾
      j--;
    } else if (pi[i][j] === 2) {
      // 去头和去尾
      result[p++] = arr[i];
      result[q--] = arr[j];
      i++;
      j--;
    }
  }
  console.log(result.toString());
  return f[0][n - 1];
}
var test2 = "cxsahasejiasdanxnasdaijasdehoq";
console.log(longestPalindromeSubseq_2(test2));
// s,a,j,i,a,s,a,n,x,n,a,s,a,i,j,a,s
// 17
```

- 记忆化搜索
  1. 递归中有大量的重复进计算，为了避免重复计算，把已经计算过的存下了，下次有用到直接去读取，不用去重复计算
  2. 记忆化搜索与递推的区别：递推是从下往上 f[0]...f[N]，而记忆化搜索是从上往下 f(N)...f(N-1)
  3. 递推可以使用滚动数据优化空间复杂度，而记忆化搜索必须存储所有的 f 值
  4. 因为区间型动态规划的递推是从大到小的，适合使用记忆化搜索

```js
// 记忆化搜索方法
var f = null;
var arr = null;
function Computed(i, j) {
  if (f[i][j] !== -1) {
    return;
  }
  if (i === j) {
    f[i][i] = 1;
    return;
  }
  if (i + 1 === j) {
    f[i][i + 1] = arr[i] === arr[i + 1] ? 2 : 1;
    return;
  }
  Computed(i + 1, j);
  Computed(i, j - 1);
  Computed(i + 1, j - 1);

  f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
  if (arr[i] === arr[j]) {
    f[i][j] = Math.max(f[i][j], f[i + 1][j - 1] + 2);
  }
}
function longestPalindromeSubseq_3(s) {
  arr = s.split("");
  var n = arr.length;
  if (n === 0) {
    return 0;
  }
  f = twoDimensionArr(n, n);
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      f[i][j] = -1;
    }
  }
  Computed(0, n - 1);
  return f[0][n - 1];
}
var test3 = "cxsahasejiasdanxnasdaijasdehoq";
console.log(longestPalindromeSubseq_3(test3));
// 17
```

2. **一条线上的硬币 3(博弈加区间)**

- 给定一个序列 a[0],...a[N-1]，两个玩家 A 和 B 轮流取数，每个人每次只能取第一个数或者最后一个数，双方都用最优策略，使得自己的数字和尽量比对手大
- 问：`先手是否必胜`
- 如：[1,5,233,7]，输出 true（先手取走 1，无论后手取那个，先手都能取走 233）
- 目的：让自己拿到的数字之和不比对手小，可设自己的数字和为 A,对手的数字和为 B，目标是 A>=B，等价于 A-B>=0，
- 转换：
  1. 也就是说各自都存储着自己的数字和与对手的数字和之差，分别是 S[A]=A-B，S[B]=B-A,则自己和对手都需要最大化 S[A]和 S[B]
  2. 当 X 面对剩下的数字，可以认为 X 是就当前的先手，他的目标是最大化 S[x]=x-y;当他取走 m 之后，先手换成了 Y，Y 的目标就是最大化 S[y]=y-x，又因为 S[X]=-S[Y]，当 X 取走 m 时 S[X]=S[X]+m=-S[Y]+m
  3. 把 A，B 变成数字差，先手取了 M 后的转换式子，然后 X 有两种选择，取第一个数字 m1 或最后一个数字 m2，为了最大化 S[X]，应该选择较大的 S[X]
- 确定状态
  1. 第一步：
  1. 如果 A 第一步取走 a[0]，B 在剩下 a[1...N-1]中取，B 的最大数字差 S[Y]，那么 S[X] = a[0]-S[Y]
  1. 如果 A 第一步取走 a[n-1]，B 在剩下 a[0...N-2]中取，B 的最大数字差 S[Y]'，那么 S[X] = a[n-1]-S[Y]'
  1. 那么 A 选择最大的数字差
  1. 子问题：A 取完后，先手成 B，因为 B 这时候面对的是 a[1...N-1]，少了一个数字，但是还要面对与 A 的数字差最大，这就是一个子问题
  1. 状态：设 f[i][j]一方先手为面对 a[i...j]这些数字时，能得到最大与对手的数字差
- 转义方程
  1. f[i][j] = max{f[i]-f[i+1][j],f[j]-f[i][j-1]}
  2. f[i]-f[i+1][j]（取头，对手采取最优策略时、自己得到的最大的与对手的数字差）
  3. f[j]-f[i][j-1]（取尾，对手采取最优策略时、自己得到的最大的与对手的数字差）
- 初始条件与边缘情况
  1. f[i][j] = a[i](i=0,...,n-1) 只有一个数字，自己得了 a[i]分，对手 0 分，数字差为 a[i]
- 计算顺序
  1. 长度 1:f[0][0],...,f[N-1][n-1]
  2. 长度 2:f[0][1],...,f[N-2][n-1]
  3. ...
  4. 长度 N:f[0][n-1]
  5. 结果 f[0][n-1]>=0，则 A 必胜

```js
function twoDimensionArr(m, n, val = undefined) {
  var arr = [];
  for (var i = 0; i < m; i++) {
    var col = [];
    for (var j = 0; j < n; j++) {
      col[j] = val;
    }
    arr[i] = col;
  }
  return arr;
}
function firstWillWin(arr) {
  var m = arr.length;
  if (m === 0) {
    return 0;
  }
  var f = twoDimensionArr(m, m);
  var len;
  for (var i = 0; i < m; i++) {
    f[i][i] = arr[i];
  }
  for (len = 2; len <= m; len++) {
    for (var i = 0; i <= m - len; i++) {
      var j = i + len - 1;
      f[i][j] = Math.max(arr[i] - f[i + 1][j], arr[j] - f[i][j - 1]);
    }
  }
  return f[0][m - 1] >= 0;
}
var test = [1, 5, 233, 7];
console.log(firstWillWin(test));
// true
```
