## 递归与分治

1. 递归：程序调用自身称为递归，用有限的语句来定义对象的无限集合，边界条件与递归方程递归函数的两个重要因素

## 递归与调用栈

1. 递归有前行和退回阶段，递归过程退回的顺序是它前行的逆序，这就是调用栈，先进后出
2. 递归在回退过程中要执行某些动作，包括恢复在前进过程中存储起来的某些数据
3. 前行阶段，对于每一层递归，函数的局部变量、参数值、返回地址都会被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址都会弹出，用于返回调用层次中执行代码的其余部分，也就是恢复调用状态

```js
function f(m) {
  if (m < 0) {
    return;
  }
  console.log(m);
  f(m - 1);
  console.log(m);
}
f(5);
// 输出
// 5
// 4
// 3
// 2
// 1
// 0
// 0
// 1
// 2
// 3
// 4
// 5
```

## 递归使用

1. 阶乘

```js
function factorial(n) {
  return n === 0 ? 1 : n * factorial(n - 1);
}
```

2. 斐波那契数列

```js
function fibonacci(n) {
  if (n === 0) return 0;
  else if (n <= 2) return 1;
  else return fibonacci(n - 1) + fibonacci(n - 2);
}
```

3.  全排列

    1. 从 n 个不同元素中任取 m（m<=n）个元素，按照一定的顺序排列起来，叫做从 n 个不同元素中取出 m 个元素的一个排列，当 m==n 时所有的排列情况称为全排列
    2. 123 的全排列有：123、132、213、231、321、312 这六种
    3. 问：`使用递归算法生成 n 个元素的[r1,r2,...,rn]的全排列`
    4. **将整数组中的所有的数分别与第一个数交换，这样总是在处理 n-1 个数的全排列**

    ```js
    function perm(list, k, m) {
      if (k === m) {
        var str = "";
        for (var i = 0; i < m; i++) {
          str += list[i];
        }
        console.log(str);
      } else {
        for (var i = k; i < m; i++) {
          [list[k], list[i]] = [list[i], list[k]];
          perm(list, k + 1, m);
          [list[k], list[i]] = [list[i], list[k]];
        }
      }
    }
    var arr = ["a", "b", "c"];
    perm(arr, 0, arr.length);
    ```

4.  整数划分问题
    1. n = m1+m2+m3+...+mi（mi 为整数，1<=mi<=n）,则{m1,m2,...,mi}为 n 的一个划分
    2. 如果{m1,m2,...,mi}的最大值不超过 m，max(m1,m2,...,mi)<=m，则称为属于 n 的一个 m 划分，用 f(n,m)表示
    3. n 为 4 有 5 种划分 {4},{3,1},{2,2},{2,1,1},{1,1,1,1}
    4. 问：`n 的所有划分个数 f(n,n)`
    5. **当 n===1 || m===1 只有一个划分 {1} 和 n 个 1 {1...1}**
    6. **当 n===m 时，包含 n，只有{n}，不包含 n，划分中最大的数字一定比 n 小，所以就是 n 的 n-1 划分，就是 f(n,n-1)**
    7. **当 n<m 时，不可能出现，比如 3 的划分最大值是 7，这种情况不可能出现**
    8. **当 n>m 是，包含 m，即{m, {x1,x2,...xi}}，即{x1,x2,...xi}的和为 n-m，即 n-m 的 m 划分，即 f(n-m,m)，不包含 m，即所有划分都比 m 小，即 n 的 m-1h 划分，即 f(n,m-1)**
    ```js
    function division(n, m) {
      // n或者m等于的1的时候，只有1个
      if (n === 1 || m === 1) return 1;
      // n===m的时候，包含n，就是{n}一个，不包含n就是n的n-1，合一起就是1+f(n,n-1)
      else if (n === m) return 1 + division(n, n - 1);
      // n<m 不存在，和n===m情况一样
      else if (n < m) return division(n, n);
      // n>m 包含m，就是f(n-m,m) 不包含m，就是f(n,m-1)
      else if (n > m) return division(n - m, m) + division(n, m - 1);
    }
    console.log(division(4, 4));
    console.log(division(6, 6));
    // 5
    // 11
    ```
