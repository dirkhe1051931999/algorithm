# 贪心算法

## 基本概念

1. 不从整体最优上考虑，只做局部最优解
2. 贪心算法不是对所有问题都能得到整体最优解
3. 贪心算法无后效性，某个状态以后的过程不会影响以前的状态，只与当前状态有关

## NP 完全问题

1. NP（Non-deterministic Polynomial）完全问题（多项式复杂程度的非确定性问题）：需要计算所有的解，并从中选择出最小/最短的那个
2. P 能在多项式时间内解决的问题，P 是否等于 NP：对于一个问题是否在多项式时间内验证其答案的正确性

- 如何识别是否是 NP 完全问题：

1. 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢
2. 涉及“所有组合”的问题通常是 NP 完全问题
3. 不能将问题分成小问题，必须考虑各种可能的情况。这可能是 NP 完全问题
4. 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是 NP 完全问题
5. 如果问题涉及集合（如广播台集合）且难以解决，它可能就是 NP 完全问题
6. 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是 NP 完全问题

- 贪心算法与 NP 完全问题

1. 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解
2. 对于 NP 完全问题，还没有找到快速解决方案
3. 面临 NP 完全问题时，最佳的做法是使用近似算法
4. 贪婪算法易于实现、运行速度快，是不错的近似算法

## 基本思路

1. 建立数学模型描述问题
2. 把求解问题分成若干个子问题
3. 对每一个子问题求解，得到子问题的局部最优解
4. 把子问题的局部最优解合成原来问题的一个解

## 适用场景

## 实现思路

## 具体使用

1. 活动选择问题

   > 有 n 个需要在同一天使用同一个教室的活动 a1,a2,...an，教室同一时刻只能由一个活动使用，每个活动 ai 都有一个开始时间 start[i]与 end[i],一旦被选则后，教室就被占据了，这个时间段就不能上其他活动，`需要选择尽量多的活动而不冲突`，按照数学归纳法，**每次选择结束最早的活动，最终可以选到最多的活动**

   ![](../pic/greedy-1.png)

   ```js
   function getMaxCas(start, end) {
     var pre = 0;
     var result = [];
     for (i = 1; i < start.length; i++) {
       if (i === 1) result.push([start[i - 1], end[i - 1]]);
       if (start[i] >= end[pre]) {
         pre = i;
         result.push([start[i], end[i]]);
       }
     }
     return result;
   }
   let start = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12];
   let end = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
   console.log(getMaxCas(start, end));
   // [ [ 1, 4 ], [ 5, 7 ], [ 8, 11 ], [ 12, 14 ] ]
   ```

2. 钱币找零问题
   > 假设有 1, 2, 5, 10, 20, 50, 100 各若干张纸币，`问用这些钱支付K元，至少需要多少张`，**每次尽可能用最大的纸币，最终选择的纸币就会是最少的**
   ```js
   function solve(obj, val, money) {
     var count = 0;
     var arr = [];
     while (money > 0) {
       for (var i = val.length - 1; i >= 0; i--) {
         // 每次都从面值最大开始选择，直到money小于0
         if (val[i] <= money) {
           money -= val[i];
           count++;
           obj[val[i]]++;
           arr.push(val[i]);
           break;
         }
       }
     }
     console.log("最少需要", count, "张纸币");
     console.log("分别是：");
     for (var key in obj) {
       if (obj[key]) {
         console.log(key, "元需要", obj[key] + "张");
       }
     }
   }
   var obj = {
     1: 0,
     2: 0,
     5: 0,
     10: 0,
     20: 0,
     50: 0,
     100: 0
   };
   var val = [1, 2, 5, 10, 20, 50, 100];
   solve(obj, val, 124);
   // 最少需要 4 张纸币
   // 分别是：
   // 2 元需要 2张
   // 20 元需要 1张
   // 100 元需要 1张
   ```
3. 背包问题
   > 选择物品 i 装入背包时，可以选择物品的一部分，不一定全部装入背包。**选择单位重量价值最高的物品，将尽可能多的该物品装入背包，直到小于等于背包总重量**
   ```js
   function knapsack() {
     // 拿几次
     var N = 4;
     // 总重量
     var A = 50;
     // 每个物品的重量
     var W = [0, 10, 30, 20, 5];
     // 每个物品的价值
     var V = [0, 200, 400, 100, 10];
     // 记录结果
     var X = [];
     X[N + 1] = 0;
     // 索引
     var i = 1;
     // 物品整件装下
     for (i = 1; i <= N; i++) {
       // 如果其中有一个物品重量大于总重量，退出
       if (W[i] > A) break;
       // 占位
       X[i] = 1;
       // 减去重量
       A -= W[i];
     }
     // 前几个完整的拿了，这步是拿剩下的部分的重量
     if (i <= N) {
       X[i] = A / W[i];
     }
     for (var j = 1; j <= N; j++) {
       console.log("第", j, "个，重量为", W[j], "，拿", X[j] ? X[j] : 0, "个");
     }
   }
   knapsack();
   // 第 1 个，重量为 10 ，拿 1 个
   // 第 2 个，重量为 30 ，拿 1 个
   // 第 3 个，重量为 20 ，拿 0.5 个
   // 第 4 个，重量为 5 ，拿 0 个
   ```
4. 多机调度问题

   1. n 个作业组成作业集，由 m 台相同的机器加工，作业不能拆分成更小，每个作业均可在任何一台机器上加工处理
   2. 问：`要求给出一个作业调度，使所给的n个作业在尽可能短的时间由m台及其加工处理完成`
   3. 这是一个 NP 完全问题，没有有效的解法，可用贪心算法设计出较好的近似算法
   4. **当 n<=m，也就是机器多，作业组少，把作业组分为机器就行**
   5. **当 n>m，也就是机器少，作业组多，先把作业组，从大到小排序，依次分配给空闲的机器，直到作业组处理完毕**
   6. 如果先处理最作业时间最短的，那么就存在作业时间最短的已经都处理完了，空了几个机器，但是还在等作业时间最长的及其处理

   ```js
   function scheduling() {
     // 作业组
     var n = 6;
     // 机器数量
     var m = 4;
     // 每个作业组的速度
     var speed = [20, 5, 15, 25, 30, 10];
     // 排序
     speed.sort((a, b) => {
       return a < b;
     });
     // 最小时间
     var mintime = new Array(m);
     mintime.fill(0);
     for (var i = 0; i < n; i++) {
       var min = Math.min.apply(null, mintime);
       if (i < m) {
         mintime[i] = min + speed[i];
       }
     }
     console.log("最少需要的时间", Math.max.apply(null, mintime));
   }
   scheduling();
   // 最少需要的时间 30
   ```

5. 小船过河问题
   1. 只有一艘船，能乘 2 人，运行 2 人的速度是是 2 人中较慢一人的速度，过去之后还需要一个人把船划回来
   2. 问：`把n个人运到对岸去，最少需要多久`
   3. 先将所有人过河的时间从大到小排序，有两种方案
   4. **最快与次快过河，最快返回，最慢与次慢过河，次快返回，需要时间：t[1]+t[0]+t[n-1]+t[1]**
   5. **最快与最慢过河，最快返回，最快与次慢过河，最快返回（大神带猪队友），需要时间 t[n-1]+t[0]+t[n-2]+t[0]**
   ```js
   function crossRiver() {
     var sum = 0;
     var n = 10;
     // 随机10个时间
     var t = [7, 3, 5, 8, 10, 2, 1, 9, 11, 6];
     // 排序
     t.sort((a, b) => {
       return a > b;
     });
     while (n > 3) {
       sum = Math.min(
         sum + t[1] + t[0] + t[n - 1] + t[1],
         sum + t[n - 1] + t[0] + t[n - 2] + t[0]
       );
       n -= 2;
     }
     // 剩三个人，所需时间加上，第1 2 3 个人的时间
     if (n === 3) sum += t[0] + t[1] + [2];
     // 剩两个人，所需时间加上第二个人的时间
     else if (n === 2) sum += t[1];
     // 剩1个人的时候，所以时间加上第一个人的时间
     else sum += t[0];
     console.log(t, `该${t.length}人最少需要时间为`, sum);
   }
   crossRiver();
   // [1, 2, 3, 5, 6, 7, 8, 9, 10, 11 ] '该10人最少需要时间为' 54
   ```
6. 区间覆盖问题
   1. 海岸线是一条无限延伸的直线，陆地在海岸线的一侧，海洋在另一侧，每一个岛屿是海洋的一个点，雷达坐落在海岸线上，最多覆盖 d 距离
   2. 每一个岛屿，都可以计算出一个雷达所在的区间，需要尽可能少的点覆盖这些区间
   3. 问：`计算出能覆盖给出的岛屿的最少雷达数`
   4. **先将所有区间按照左边点大小排序**
   5. **如果两个区间相交不重合，什么都不做**
   6. **如果一个区间是另一个区间的子级，更新右端点**
   7. **如果两个区间不相交，需要增加点并更新右端点**
   ```js
   function coverage() {
     // 岛屿数
     var n = 5;
     // 最大距离
     var d = 6;
     // 最少雷达
     var count = 1;
     // 存储数据
     var arr = new Array(n);
     // 岛屿位置
     var point = [[3, 4], [1, 2], [1, 1], [15, 2], [200, 5]];
     // 获取每个岛屿的区间
     for (var i = 0; i <= n - 1; i++) {
       var obj = {};
       var x = point[i][0];
       var y = point[i][1];
       if (y > d) {
         return -1;
       }
       var t = Math.sqrt(d * d - y * y);
       obj.left = x - t;
       obj.right = x + t;
       arr[i] = obj;
     }
     // 区间按照left从小到达排序
     arr.sort((a, b) => {
       return a.left > b.left;
     });
     var s = arr[0].right;
     // 比较区间是否重叠
     for (var i = 1; i <= n - 1; i++) {
       // 两个区间不相交，需要增加点，并且更新右端点
       if (arr[i].left > s) {
         count++;
         s = arr[i].right;
       } else if (arr[i].right < s) {
         // 如果包含，只需要更新右端点
         s = arr[i].right;
       } else {
         // 如果相交，什么都不做
       }
     }
     console.log(arr);
     return count;
   }
   console.log("至少需要雷达数", coverage());
   // 至少需要雷达数 3
   ```
7. 销售比赛
8. Huffman 编码
9. Dijkstra 算法
10. 最小生成树算法
