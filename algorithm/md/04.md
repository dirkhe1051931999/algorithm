# 贪心算法

## 基本概念

1. 不从整体最优上考虑，只做局部最优解
2. 贪心算法不是对所有问题都能得到整体最优解
3. 贪心算法无后效性，某个状态以后的过程不会影响以前的状态，只与当前状态有关

## NP 完全问题

1. NP（Non-deterministic Polynomial）完全问题（多项式复杂程度的非确定性问题）：需要计算所有的解，并从中选择出最小/最短的那个
2. P 能在多项式时间内解决的问题，P 是否等于 NP：对于一个问题是否在多项式时间内验证其答案的正确性

- 如何识别是否是 NP 完全问题：

1. 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢
2. 涉及“所有组合”的问题通常是 NP 完全问题
3. 不能将问题分成小问题，必须考虑各种可能的情况。这可能是 NP 完全问题
4. 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是 NP 完全问题
5. 如果问题涉及集合（如广播台集合）且难以解决，它可能就是 NP 完全问题
6. 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是 NP 完全问题

- 贪心算法与 NP 完全问题

1. 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解
2. 对于 NP 完全问题，还没有找到快速解决方案
3. 面临 NP 完全问题时，最佳的做法是使用近似算法
4. 贪婪算法易于实现、运行速度快，是不错的近似算法

## 基本思路

1. 建立数学模型描述问题
2. 把求解问题分成若干个子问题
3. 对每一个子问题求解，得到子问题的局部最优解
4. 把子问题的局部最优解合成原来问题的一个解

## 适用场景

## 实现思路

## 具体使用

1. 活动选择问题

   > 有 n 个需要在同一天使用同一个教室的活动 a1,a2,...an，教室同一时刻只能由一个活动使用，每个活动 ai 都有一个开始时间 start[i]与 end[i],一旦被选则后，教室就被占据了，这个时间段就不能上其他活动，`需要选择尽量多的活动而不冲突`，按照数学归纳法，**每次选择结束最早的活动，最终可以选到最多的活动**

   ![](../pic/greedy-1.png)

   ```js
   function getMaxCas(start, end) {
     var pre = 0;
     var result = [];
     for (i = 1; i < start.length; i++) {
       if (i === 1) result.push([start[i - 1], end[i - 1]]);
       if (start[i] >= end[pre]) {
         pre = i;
         result.push([start[i], end[i]]);
       }
     }
     return result;
   }
   let start = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12];
   let end = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
   console.log(getMaxCas(start, end));
   // [ [ 1, 4 ], [ 5, 7 ], [ 8, 11 ], [ 12, 14 ] ]
   ```

2. 钱币找零问题
   > 假设有 1, 2, 5, 10, 20, 50, 100 各若干张纸币，`问用这些钱支付K元，至少需要多少张`，**每次尽可能用最大的纸币，最终选择的纸币就会是最少的**
   ```js
   function solve(obj, val, money) {
     var count = 0;
     var arr = [];
     while (money > 0) {
       for (var i = val.length - 1; i >= 0; i--) {
         // 每次都从面值最大开始选择，直到money小于0
         if (val[i] <= money) {
           money -= val[i];
           count++;
           obj[val[i]]++;
           arr.push(val[i]);
           break;
         }
       }
     }
     console.log("最少需要", count, "张纸币");
     console.log("分别是：");
     for (var key in obj) {
       if (obj[key]) {
         console.log(key, "元需要", obj[key] + "张");
       }
     }
   }
   var obj = {
     1: 0,
     2: 0,
     5: 0,
     10: 0,
     20: 0,
     50: 0,
     100: 0
   };
   var val = [1, 2, 5, 10, 20, 50, 100];
   solve(obj, val, 124);
   // 最少需要 4 张纸币
   // 分别是：
   // 2 元需要 2张
   // 20 元需要 1张
   // 100 元需要 1张
   ```
3. 背包问题
   > 选择物品 i 装入背包时，可以选择物品的一部分，不一定全部装入背包。**选择单位重量价值最高的物品，将尽可能多的该物品装入背包，直到小于等于背包总重量**
   ```js
   function knapsack() {
     // 拿几次
     var N = 4;
     // 总重量
     var A = 50;
     // 每个物品的重量
     var W = [0, 10, 30, 20, 5];
     // 每个物品的价值
     var V = [0, 200, 400, 100, 10];
     // 记录结果
     var X = [];
     X[N + 1] = 0;
     // 索引
     var i = 1;
     // 物品整件装下
     for (i = 1; i <= N; i++) {
       // 如果其中有一个物品重量大于总重量，退出
       if (W[i] > A) break;
       // 占位
       X[i] = 1;
       // 减去重量
       A -= W[i];
     }
     // 前几个完整的拿了，这步是拿剩下的部分的重量
     if (i <= N) {
       X[i] = A / W[i];
     }
     for (var j = 1; j <= N; j++) {
       console.log("第", j, "个，重量为", W[j], "，拿", X[j] ? X[j] : 0, "个");
     }
   }
   knapsack();
   // 第 1 个，重量为 10 ，拿 1 个
   // 第 2 个，重量为 30 ，拿 1 个
   // 第 3 个，重量为 20 ，拿 0.5 个
   // 第 4 个，重量为 5 ，拿 0 个
   ```
4. 多机调度问题

   1. n 个作业组成作业集，由 m 台相同的机器加工，作业不能拆分成更小，每个作业均可在任何一台机器上加工处理
   2. 问：`要求给出一个作业调度，使所给的n个作业在尽可能短的时间由m台及其加工处理完成`
   3. 这是一个 NP 完全问题，没有有效的解法，可用贪心算法设计出较好的近似算法
   4. **当 n<=m，也就是机器多，作业组少，把作业组分为机器就行**
   5. **当 n>m，也就是机器少，作业组多，先把作业组，从大到小排序，依次分配给空闲的机器，直到作业组处理完毕**
   6. 如果先处理最作业时间最短的，那么就存在作业时间最短的已经都处理完了，空了几个机器，但是还在等作业时间最长的及其处理

   ```js
   function scheduling() {
     // 作业组
     var n = 6;
     // 机器数量
     var m = 4;
     // 每个作业组的速度
     var speed = [20, 5, 15, 25, 30, 10];
     // 排序
     speed.sort((a, b) => {
       return a < b;
     });
     // 最小时间
     var mintime = new Array(m);
     mintime.fill(0);
     for (var i = 0; i < n; i++) {
       var min = Math.min.apply(null, mintime);
       if (i < m) {
         mintime[i] = min + speed[i];
       }
     }
     console.log("最少需要的时间", Math.max.apply(null, mintime));
   }
   scheduling();
   // 最少需要的时间 30
   ```

5. 小船过河问题
6. 区间覆盖问题
7. 销售比赛
8. Huffman 编码
9. Dijkstra 算法
10. 最小生成树算法
