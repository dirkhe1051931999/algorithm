# 位操作型动态规划

1. **比特位计数(leetcode 338)**

- 给定一个非负整数 num，对于 0 ≤ i ≤ num 范围中的每个数字 i ，
- 问：`计算其二进制数中的 1 的数目并将它们作为数组返回`

1. 确定状态
   (170)10=(10101010)2，去掉最后一个 0
   (85)10=(1010101)2，去掉最后一个 1
   (42)10=(101010)2,去掉最后一个 0
   (21)10=(10101)2,去掉最后一个 1
   (10)10=(1010)2,去掉最后一个 0
   (5)10=(101)2,去掉最后一个 1
   (2)10=(10)2,去掉最后一个 0
   (1)10=(1)2,去掉最后一个 1
   (0)10=(0)2,去掉最后一个 1
1. 需要确定最后一位去掉后，新的 2 进制有多少个 1，要求 N 的二进制表示中多少 1，在 N 的二进制去掉最后一位 N mod 2，设新的数是 Y=(N>>1)，要知道 Y 的二进制有多少 1
1. 子问题：
1. 状态：设 f[i]表示 i 的二进制表示有多少个 1

- 转义方程
  1. f[i] = f[i>>1] + (i mod 2) ,f[i>>1]:i 的二进制表示中去掉最后一位，剩下 1 的个数，(i mod 2)i 的二进制表示中最后一位
- 初始条件与边缘情况
  f[0] = 0
- 计算顺序
  从小到大，返回 f[0],..,f[n]

```js
function countBits(num) {
  var f = new Array(num + 1);
  // 初始条件
  f[0] = 0;
  for (var i = 1; i <= num; i++) {
    // 转义方程
    f[i] = (i & 1) + f[i >> 1];
  }
  return f;
}
var test = 2;
console.log(countBits(test));
// [ 0, 1, 1 ]
```
